[[_subtree_merge]]
===== Fusión de Subárbol

La idea de la fusión de subárbol es que tienes dos proyectos, y uno de los proyectos se mapea a un subdirectorio del otro. Cuando especificas una fusión de subárbol, Git es a menudo lo suficientemente inteligente como para descubrir que uno es un subárbol del otro y fusionar adecuadamente.

Pasaremos por un ejemplo de cómo añadir un proyecto separado a un proyecto existente y luego fusionar el código del segundo en un subdirectorio del primero.

Primero, añadiremos la aplicación Rack a nuestro proyecto. Añadiremos el proyecto Rack como una referencia remota en nuestro propio proyecto y luego lo revisaremos en su propia rama:

[source,console]
----
$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -> rack_remote/build
 * [new branch]      master     -> rack_remote/master
 * [new branch]      rack-0.4   -> rack_remote/rack-0.4
 * [new branch]      rack-0.9   -> rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"
----

Ahora tenemos la raíz del proyecto Rack en nuestra rama `rack_branch` y nuestro propio proyecto en la rama `master`. Si revisas uno y luego el otro, puedes ver que tienen diferentes raíces de proyecto:

[source,console]
----
$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README
----

Este es un concepto un tanto extraño. No todas las ramas en tu repositorio realmente tienen que ser ramas del mismo proyecto. No es común, porque rara vez es útil, pero es bastante fácil tener ramas que contienen historias completamente diferentes.

En este caso, queremos extraer el proyecto Rack en nuestro proyecto `master` como un subdirectorio. Podemos hacer eso en Git con `git read-tree`. Aprenderás más sobre `read-tree` y sus amigos en <<ch10-git-internals#ch10-git-internals>>, pero por ahora, ten en cuenta que lee el árbol raíz de una rama en tu área de preparación actual y directorio de trabajo. Acabamos de volver a tu rama `master`, y extraemos la rama `rack_branch` en el subdirectorio `rack` de nuestra rama `master` de nuestro proyecto principal:

[source,console]
----
$ git read-tree --prefix=rack/ -u rack_branch
----

Cuando hacemos commit, parece que tenemos todos los archivos de Rack bajo ese subdirectorio, como si los hubiéramos copiado desde un tarball. Lo que se vuelve interesante es que podemos fusionar cambios de una de las ramas a la otra de manera bastante fácil. Así que, si el proyecto Rack se actualiza, podemos extraer cambios aguas arriba cambiando a esa rama y extrayendo:

[source,console]
----
$ git checkout rack_branch
$ git pull
----

Luego, podemos fusionar esos cambios de vuelta a nuestra rama `master`. Para extraer los cambios y pre-poblar el mensaje de commit, usa la opción `--squash`, así como la opción `-Xsubtree` de la estrategia de fusión recursiva. La estrategia recursiva es la predeterminada aquí, pero la incluimos para mayor claridad.

[source,console]
----
$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
----

Todos los cambios del proyecto Rack se fusionan y están listos para ser confirmados localmente. También puedes hacer lo contrario: hacer cambios en el subdirectorio `rack` de tu rama `master` y luego fusionarlos en tu rama `rack_branch` más tarde para enviarlos a los mantenedores o empujarlos aguas arriba.

Esto nos da una manera de tener un flujo de trabajo algo similar al flujo de trabajo de submódulos sin usar submódulos (que cubriremos en <<ch07-git-tools#_git_submodules>>). Podemos mantener ramas con otros proyectos relacionados en nuestro repositorio y fusionarlos ocasionalmente en nuestro proyecto. Es agradable en algunos aspectos, por ejemplo, todo el código se confirma en un solo lugar. Sin embargo, tiene otras desventajas, como que es un poco más complejo y más fácil de cometer errores al reintegrar cambios o empujar accidentalmente una rama a un repositorio no relacionado.

Otra cosa un poco extraña es que para obtener un diff entre lo que tienes en tu subdirectorio `rack` y el código en tu rama `rack_branch`, para ver si necesitas fusionarlos, no puedes usar el comando `diff` normal. En su lugar, debes ejecutar `git diff-tree` con la rama con la que quieres comparar:

[source,console]
----
$ git diff-tree -p rack_branch
----

O, para comparar lo que está en tu subdirectorio `rack` con lo que estaba en la rama `master` en el servidor la última vez que hiciste fetch, puedes ejecutar:

[source,console]
----
$ git diff-tree -p rack_remote/master
----
