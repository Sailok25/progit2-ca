[[_git_submodules]]
=== Submòduls

Sovint passa que, mentre treballes en un projecte, necessites utilitzar un altre projecte dins d'aquest. Potser és una llibreria que ha desenvolupat un tercer o que estàs desenvolupant per separat i utilitzant en múltiples projectes principals. Un problema comú en aquests escenaris és que vols poder tractar els dos projectes com a separats i encara poder utilitzar un dins de l'altre.

Aquí tens un exemple. Suposem que estàs desenvolupant un lloc web i creant feeds Atom. En lloc de escriure el teu propi codi generador d'Atom, decides utilitzar una llibreria. És probable que hagis d'incloure aquest codi des d'una llibreria compartida com una instal·lació CPAN o una gema Ruby, o copiar el codi font al teu propi arbre de projecte. El problema d'incloure la llibreria és que és difícil personalitzar-la de qualsevol manera i sovint més difícil de desplegar-la, perquè has d'assegurar-te que cada client tingui aquesta llibreria disponible. El problema de copiar el codi al teu propi projecte és que qualsevol canvi personalitzat que facis és difícil de fusionar quan els canvis a munt es fan disponibles.

Git aborda aquest problema utilitzant submòduls. Els submòduls et permeten mantenir un repositori Git com a subdirectori d'un altre repositori Git. Això et permet clonar un altre repositori al teu projecte i mantenir els teus commits separats.

[[_starting_submodules]]
==== Començant amb Submòduls

Passarem per desenvolupar un projecte senzill que s'ha dividit en un projecte principal i alguns subprojectes.

Comencem afegint un repositori Git existent com a submòdul del repositori en què estem treballant. Per afegir un nou submòdul utilitzes el comandament `git submodule add` amb l'URL absolut o relatiu del projecte que vols començar a seguir. En aquest exemple, afegirem una llibreria anomenada "`DbConnector`".

[source,console]
----
$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

Per defecte, els submòduls afegiran el subprojecte en un directori anomenat igual que el repositori, en aquest cas "`DbConnector`". Pots afegir una ruta diferent al final del comandament si vols que vagin a un altre lloc.

Si executes `git status` en aquest punt, notaràs algunes coses.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector
----

Primer has de notar el nou fitxer `.gitmodules`. Aquest és un fitxer de configuració que emmagatzema el mapeig entre l'URL del projecte i el subdirectori local on l'has descarregat:

[source,ini]
----
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector
----

Si tens múltiples submòduls, tindràs múltiples entrades en aquest fitxer. És important tenir en compte que aquest fitxer està controlat per versions amb els teus altres fitxers, com el teu fitxer `.gitignore`. S'empeny i s'estira amb la resta del teu projecte. Així és com altres persones que clonen aquest projecte saben d'on obtenir els projectes dels submòduls.

[NOTE]
=====
Ja que l'URL al fitxer `.gitmodules` és el que altres persones intentaran clonar/descarregar primer, assegura't d'utilitzar una URL a la qual puguin accedir si és possible. Per exemple, si utilitzes una URL diferent per empenyer que la que altres utilitzarien per estirar, utilitza la que altres tenen accés. Pots sobreescriure aquest valor localment amb `git config submodule.DbConnector.url PRIVATE_URL` per al teu ús. Quan sigui aplicable, una URL relativa pot ser útil.
=====

L'altra llista a la sortida de `git status` és l'entrada del directori del projecte. Si executes `git diff` en això, veuràs alguna cosa interessant:

[source,console]
----
$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc
----

Tot i que `DbConnector` és un subdirectori al teu directori de treball, Git el veu com un submòdul i no segueix el seu contingut quan no estàs en aquest directori. En lloc d'això, Git el veu com un commit particular d'aquest repositori.

Si vols una sortida de diff una mica més agradable, pots passar l'opció `--submodule` a `git diff`.

[source,console]
----
$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
----

Quan fas commit, veuràs alguna cosa com això:

[source,console]
----
$ git commit -am 'Add DbConnector module'
[master fb9093c] Add DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector
----

Nota el mode `160000` per a l'entrada `DbConnector`. Aquest és un mode especial a Git que bàsicament significa que estàs registrant un commit com una entrada de directori en lloc d'un subdirectori o un fitxer.

Finalment, empeny aquests canvis:

[source,console]
----
$ git push origin master
----

[[_cloning_submodules]]
==== Clonant un Projecte amb Submòduls

Aquí clonarem un projecte amb un submòdul dins. Quan clones un projecte així, per defecte obtens els directoris que contenen submòduls, però cap dels fitxers dins d'ells encara:

[source,console]
----
$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$
----

El directori `DbConnector` està aquí, però buit. Has d'executar dos comandaments des del projecte principal: `git submodule init` per inicialitzar el teu fitxer de configuració local, i `git submodule update` per obtenir totes les dades d'aquest projecte i revisar el commit apropiat llistat al teu superprojecte:

[source,console]
----
$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

Ara el teu subdirectori `DbConnector` està en l'estat exacte en què estava quan vas fer commit abans.

Hi ha una altra manera de fer això que és una mica més senzilla, però. Si passes `--recurse-submodules` al comandament `git clone`, inicialitzarà i actualitzarà automàticament cada submòdul al repositori, incloent submòduls aniuats si algun dels submòduls al repositori té submòduls ell mateix.

[source,console]
----
$ git clone --recurse-submodules https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

Si ja has clonat el projecte i t'has oblidat de `--recurse-submodules`, pots combinar els passos `git submodule init` i `git submodule update` executant `git submodule update --init`. Per inicialitzar, obtenir i revisar qualsevol submòdul aniuat, pots utilitzar el `git submodule update --init --recursive`.

==== Treballant en un Projecte amb Submòduls

Ara tenim una còpia d'un projecte amb submòduls i col·laborarem amb els nostres companys tant en el projecte principal com en el projecte del submòdul.

===== Obtenir Canvis a Munt des del Remote del Submòdul

El model més simple d'utilitzar submòduls en un projecte seria si simplement estiguessis consumint un subprojecte i volguessis obtenir actualitzacions d'aquest de tant en tant però no estiguessis realment modificant res a la teva còpia de treball. Passem per un exemple senzill aquí.

Si vols comprovar si hi ha nova feina en un submòdul, pots anar al directori i executar `git fetch` i `git merge` la branca a munt per actualitzar el codi local.

[source,console]
----
$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -> origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)
----

Ara, si tornes al projecte principal i executes `git diff --submodule`, pots veure que el submòdul s'ha actualitzat i obtenir una llista de commits que s'han afegit. Si no vols escriure `--submodule` cada vegada que executes `git diff`, pots establir-ho com el format per defecte establint el valor de configuració `diff.submodule` a "`log`".

[source,console]
----
$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  > more efficient db routine
  > better connection routine
----

Si fas commit en aquest punt, llavors bloquejaràs el submòdul per tenir el nou codi quan altres persones actualitzin.

Hi ha una manera més fàcil de fer això, si prefereixes no obtenir i fusionar manualment al subdirectori. Si executes `git submodule update --remote`, Git entrarà als teus submòduls i obtindrà i actualitzarà per a tu.

[source,console]
----
$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -> origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'
----

Aquest comandament per defecte assumirà que vols actualitzar la revisió a la branca per defecte del repositori remot del submòdul (la que apunta `HEAD` al remot). No obstant això, pots establir això a alguna cosa diferent si vols. Per exemple, si vols que el submòdul `DbConnector` segueixi la branca "`stable`" d'aquest repositori, pots establir-ho al teu fitxer `.gitmodules` (perquè tots els altres també la segueixin), o simplement al teu fitxer local `.git/config`. Estableixem-ho al fitxer `.gitmodules`:

[source,console]
----
$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -> origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'
----

Si deixes fora `-f .gitmodules`, només farà el canvi per a tu, però probablement té més sentit seguir aquesta informació amb el repositori perquè tots els altres també ho facin.

Quan executem `git status` en aquest punt, Git ens mostrarà que tenim "`nous commits`" al submòdul.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")
----

Si estableixes l'opció de configuració `status.submodulesummary`, Git també et mostrarà un resum curt dels canvis als teus submòduls:

[source,console]
----
$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  > catch non-null terminated lines
----

En aquest punt, si executes `git diff`, podem veure tant que hem modificat el nostre fitxer `.gitmodules` com també que hi ha una sèrie de commits que hem baixat i estem llests per fer commit al nostre projecte de submòdul.

[source,console]
----
$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

Això és bastant genial perquè realment podem veure el registre de commits que estem a punt de fer commit al nostre submòdul. Un cop fet el commit, també pots veure aquesta informació després dels fets quan executes `git log -p`.

[source,console]
----
$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

Git per defecte intentarà actualitzar tots els teus submòduls quan executes `git submodule update --remote`. Si en tens molts, potser voldràs passar el nom només del submòdul que vols intentar actualitzar.

===== Obtenir Canvis a Munt des del Remote del Projecte

Ara posem-nos a la pell del teu col·laborador, que té el seu propi clon local del repositori MainProject. Simplement executar `git pull` per obtenir els teus canvis recentment confirmats no és suficient:

[source,console]
----
$ git pull
From https://github.com/chaconinc/MainProject
   fb9093c..0a24cfc  master     -> origin/master
Fetching submodule DbConnector
From https://github.com/chaconinc/DbConnector
   c3f01dc..c87d55d  stable     -> origin/stable
Updating fb9093c..0a24cfc
Fast-forward
 .gitmodules         | 2 +-
 DbConnector         | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c87d55d...c3f01dc (4):
  < catch non-null terminated lines
  < more robust error handling
  < more efficient db routine
  < better connection routine

no changes added to commit (use "git add" and/or "git commit -a")
----

Per defecte, el comandament `git pull` obté recursivament els canvis dels submòduls, com es pot veure a la sortida del primer comandament anterior. No obstant això, no els actualitza. Això es mostra per la sortida del comandament `git status`, que mostra que el submòdul està "modificat" i té "nous commits". El que és més, els claudàtors que mostren els nous commits apunten a l'esquerra (<), indicant que aquests commits estan registrats a MainProject però no estan presents a la còpia local de `DbConnector`. Per finalitzar l'actualització, has d'executar `git submodule update`:

[source,console]
----
$ git submodule update --init --recursive
Submodule path 'vendor/plugins/demo': checked out '48679c6302815f6c76f1fe30625d795d9e55fc56'

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
----

Nota que per estar al costat segur, hauràs d'executar `git submodule update` amb la bandera `--init` en cas que els commits de MainProject que acabes d'estirar hagin afegit nous submòduls, i amb la bandera `--recursive` si algun submòdul té submòduls aniuats.

Si vols automatitzar aquest procés, pots afegir la bandera `--recurse-submodules` al comandament `git pull` (des de Git 2.14). Això farà que Git executi `git submodule update` just després de l'estirada, posant els submòduls en l'estat correcte. A més, si vols que Git sempre estiri amb `--recurse-submodules`, pots establir l'opció de configuració `submodule.recurse` a `true` (això funciona per a `git pull` des de Git 2.15). Aquesta opció farà que Git utilitzi la bandera `--recurse-submodules` per a tots els comandaments que la suportin (excepte `clone`).

Hi ha una situació especial que pot ocórrer quan s'estiren actualitzacions del superprojecte: podria ser que el repositori a munt hagi canviat l'URL del submòdul al fitxer `.gitmodules` en un dels commits que estires. Això pot passar, per exemple, si el projecte del submòdul canvia la seva plataforma d'allotjament. En aquest cas, és possible que `git pull --recurse-submodules`, o `git submodule update`, fallin si el superprojecte referencia un commit del submòdul que no es troba al remot del submòdul configurat localment al teu repositori. Per remedi aquesta situació, es requereix el comandament `git submodule sync`:

[source,console]
----
# copia la nova URL a la teva configuració local
$ git submodule sync --recursive
# actualitza el submòdul des de la nova URL
$ git submodule update --init --recursive
----

===== Treballant en un Submòdul

És bastant probable que si estàs utilitzant submòduls, ho estàs fent perquè realment vols treballar en el codi del submòdul al mateix temps que estàs treballant en el codi del projecte principal (o a través de diversos submòduls). D'altra manera, probablement utilitzaries un sistema de gestió de dependències més senzill (com Maven o Rubygems).

Ara, doncs, passem per un exemple de fer canvis al submòdul al mateix temps que al projecte principal i confirmar i publicar aquests canvis al mateix temps.

Fins ara, quan hem executat el comandament `git submodule update` per obtenir canvis dels repositoris dels submòduls, Git obtindria els canvis i actualitzaria els fitxers al subdirectori però deixaria el sub-repositori en el que s'anomena un estat de "`HEAD desconnectat`". Això significa que no hi ha una branca de treball local (com `master`, per exemple) que segueixi els canvis. Sense una branca de treball que segueixi els canvis, això significa que fins i tot si fas commit de canvis al submòdul, aquests canvis es perdran probablement la propera vegada que executis `git submodule update`. Has de fer alguns passos addicionals si vols que els canvis en un submòdul siguin seguits.

Per configurar el teu submòdul perquè sigui més fàcil entrar i fer canvis, has de fer dues coses. Has d'anar a cada submòdul i revisar una branca per treballar. Després has de dir a Git què fer si has fet canvis i més tard `git submodule update --remote` obté nova feina de munt. Les opcions són que pots fusionar-los amb la teva feina local, o pots intentar rebasejar la teva feina local sobre els nous canvis.

En primer lloc, anem al nostre directori de submòduls i revisem una branca.

[source,console]
----
$ cd DbConnector/
$ git checkout stable
Switched to branch 'stable'
----

Intentem actualitzar el nostre submòdul amb l'opció "`merge`". Per especificar-la manualment, simplement podem afegir l'opció `--merge` a la nostra crida a `update`. Aquí veurem que hi havia un canvi al servidor per a aquest submòdul i es fusiona.

[source,console]
----
$ cd ..
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
----

Si anem al directori `DbConnector`, ja tenim els nous canvis fusionats a la nostra branca local `stable`. Ara veurem què passa quan fem el nostre propi canvi local a la llibreria i algú altre empeny un altre canvi a munt al mateix temps.

[source,console]
----
$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'Unicode support'
[stable f906e16] Unicode support
 1 file changed, 1 insertion(+)
----

Ara, si actualitzem el nostre submòdul, podem veure què passa quan hem fet un canvi local i munt també té un canvi que necessitem incorporar.

[source,console]
----
$ cd ..
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: Unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Si oblides el `--rebase` o `--merge`, Git simplement actualitzarà el submòdul al que hi ha al servidor i restablirà el teu projecte a un estat de HEAD desconnectat.

[source,console]
----
$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Si això passa, no et preocupis, simplement pots tornar a entrar al directori i revisar la teva branca una altra vegada (que encara contenirà la teva feina) i fusionar o rebasejar `origin/stable` (o qualsevol branca remota que vulguis) manualment.

Si no has fet commit dels teus canvis al teu submòdul i executes un `submodule update` que causaria problemes, Git obtindrà els canvis però no sobreescriurà la feina no desada al teu directori de submòduls.

[source,console]
----
$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -> origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

Si has fet canvis que entren en conflicte amb alguna cosa canviada a munt, Git t'ho farà saber quan executis l'actualització.

[source,console]
----
$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

Pots anar al directori del submòdul i corregir el conflicte com ho faries normalment.

[[_publishing_submodules]]
===== Publicant Canvis de Submòduls

Ara tenim alguns canvis al nostre directori de submòduls. Alguns d'aquests van ser portats des de munt per les nostres actualitzacions i altres van ser fets localment i encara no estan disponibles per a ningú altre ja que encara no els hem empenyat.

[source,console]
----
$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  > Merge from origin/stable
  > Update setup script
  > Unicode support
  > Remove unnecessary method
  > Add new option for conn pooling
----

Si fem commit al projecte principal i l'empenyem sense empenyar també els canvis del submòdul, altres persones que intentin revisar els nostres canvis tindran problemes ja que no tindran manera d'obtenir els canvis del submòdul dels quals depenen. Aquests canvis només existiran a la nostra còpia local.

Per assegurar-nos que això no passi, pots demanar a Git que comprovi que tots els teus submòduls han estat empenyats correctament abans d'empenyar el projecte principal. El comandament `git push` accepta l'argument `--recurse-submodules` que pot ser establert a "`check`" o "`on-demand`". L'opció "`check`" farà que `push` simplement falli si algun dels canvis del submòdul confirmats no han estat empenyats.

[source,console]
----
$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.
----

Com pots veure, també ens dona alguns consells útils sobre què podríem voler fer a continuació. L'opció simple és anar a cada submòdul i empenyar manualment als remots per assegurar-se que estiguin externament disponibles i després intentar aquest push una altra vegada. Si vols que el comportament de "`check`" passi per a tots els pushes, pots fer que aquest comportament sigui el per defecte fent `git config push.recurseSubmodules check`.

L'altra opció és utilitzar el valor "`on-demand`", que intentarà fer això per a tu.

[source,console]
----
$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -> stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -> master
----

Com pots veure, Git va entrar al mòdul `DbConnector` i el va empenyar abans d'empenyar el projecte principal. Si aquest push del submòdul falla per alguna raó, el push del projecte principal també fallarà. Pots fer que aquest comportament sigui el per defecte fent `git config push.recurseSubmodules on-demand`.

===== Fusionant Canvis de Submòduls

Si canvies una referència de submòdul al mateix temps que algú altre, podries trobar-te amb alguns problemes. És a dir, si els historials dels submòduls han divergit i s'han confirmat a branques divergents en un superprojecte, podria costar una mica de feina corregir-ho.

Si un dels commits és un avantpassat directe de l'altre (una fusió de fast-forward), llavors Git simplement triarà aquest últim per a la fusió, així que això funciona bé.

Git no intentarà ni tan sols una fusió trivial per a tu, però. Si els commits dels submòduls divergeixen i necessiten ser fusionats, obtindràs alguna cosa que sembla això:

[source,console]
----
$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -> origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

Bàsicament el que ha passat aquí és que Git ha descobert que les dues branques registren punts a l'historial del submòdul que són divergents i necessiten ser fusionats. Ho explica com "`merge following commits not found`", que és confús però ho explicarem en un moment.

Per resoldre el problema, has de descobrir en quin estat hauria d'estar el submòdul. Estranyament, Git no et dona gaire informació per ajudar aquí, ni tan sols els SHA-1 dels commits de les dues parts de l'historial. Afortunadament, és senzill descobrir-ho. Si executes `git diff`, pots obtenir els SHA-1 dels commits registrats a les dues branques que intentaves fusionar.

[source,console]
----
$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
----

Així, en aquest cas, `eb41d76` és el commit al nostre submòdul que nosaltres teníem i `c771610` és el commit que tenia munt. Si anem al nostre directori de submòduls, ja hauria d'estar a `eb41d76` ja que la fusió no l'hauria tocat. Si per qualsevol raó no ho està, simplement pots crear i revisar una branca que apunti a aquest.

El que és important és el SHA-1 del commit de l'altra part. Això és el que hauràs de fusionar i resoldre. Pots provar la fusió directament amb el SHA-1, o pots crear una branca per a això i després provar de fusionar-la. Suggerim aquesta última, fins i tot si només és per fer un missatge de commit de fusió més agradable.

Així que, anirem al nostre directori de submòduls, crearem una branca anomenada "`try-merge`" basada en aquell segon SHA-1 de `git diff`, i fusionarem manualment.

[source,console]
----
$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610

$ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.
----

Aquí vam obtenir un conflicte de fusió real, així que si resolguem això i fem commit, llavors podem simplement actualitzar el projecte principal amb el resultat.

[source,console]
----
$ vim src/main.c <1>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <2>
$ git diff <3>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <4>

$ git commit -m "Merge Tom's Changes" <5>
[master 10d2c60] Merge Tom's Changes
----

<1> Primer resolguem el conflicte.
<2> Després tornem al directori principal del projecte.
<3> Podem comprovar els SHA-1 una altra vegada.
<4> Resolguem l'entrada de submòdul en conflicte.
<5> Fem commit de la nostra fusió.

Pot ser una mica confús, però realment no és molt difícil.

Curiosament, hi ha un altre cas que Git gestiona. Si existeix un commit de fusió al directori del submòdul que conté *ambdós* commits a la seva història, Git et suggerirà com una possible solució. Veu que en algun moment al projecte del submòdul, algú va fusionar branques que contenien aquests dos commits, així que potser voldràs aquest.

Això és per què el missatge d'error de abans deia "`merge following commits not found`", perquè no podia fer *això*. És confús perquè qui s'esperaria que ho *intentés* fer?

Si troba un únic commit de fusió acceptable, veuràs alguna cosa com això:

[source,console]
----
$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

El comandament suggerit que Git està proporcionant actualitzarà l'índex com si haguessis executat `git add` (que neteja el conflicte), i llavors farà commit. Probablement no hauries de fer això, però. Pots simplement anar al directori del submòdul, veure quina és la diferència, fer un fast-forward a aquest commit, provar-lo correctament, i llavors fer-ne commit.

[source,console]
----
$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forward to a common submodule child'
----

Això aconsegueix el mateix, però almenys d'aquesta manera pots verificar que funciona i tens el codi al teu directori de submòduls quan hàgis acabat.

==== Consells sobre Submòduls

Hi ha algunes coses que pots fer per fer que treballar amb submòduls sigui una mica més fàcil.

===== Submodule Foreach

Hi ha un comandament `foreach` de submòduls per executar algun comandament arbitrari en cada submòdul. Això pot ser realment útil si tens diversos submòduls al mateix projecte.

Per exemple, suposem que volem començar una nova característica o fer una correcció d'errors i tenim feina en curs en diversos submòduls. Podem desar fàcilment tota la feina en tots els nostres submòduls.

[source,console]
----
$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable
----

Llavors podem crear una nova branca i canviar a ella en tots els nostres submòduls.

[source,console]
----
$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'
----

Entens la idea. Una cosa realment útil que pots fer és produir un diff unificat agradable del que ha canviat al teu projecte principal i a tots els teus subprojectes també.

[source,console]
----
$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&url, len, NULL, &out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;
----

Aquí podem veure que estem definint una funció en un submòdul i cridant-la al projecte principal. Això és òbviament un exemple simplificat, però espero que et doni una idea de com això pot ser útil.

===== Aliasos Útils

Potser voldràs configurar alguns aliasos per a alguns d'aquests comandaments ja que poden ser bastant llargs i no pots establir opcions de configuració per a la majoria d'ells per fer-los per defecte. Vam cobrir la configuració d'aliasos de Git a <<ch02-git-basics-chapter#_git_aliases>>, però aquí tens un exemple del que podries voler configurar si planeges treballar molt amb submòduls a Git.

[source,console]
----
$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'
----

D'aquesta manera pots simplement executar `git supdate` quan vulguis actualitzar els teus submòduls, o `git spush` per empenyar amb comprovació de dependència de submòduls.

==== Problemes amb Submòduls

No obstant això, utilitzar submòduls no està exempt de problemes.

===== Canviant de Branques

Per exemple, canviar de branques amb submòduls pot ser una mica complicat amb versions de Git més antigues que Git 2.13. Si crees una nova branca, afegeixes un submòdul allà, i després tornes a una branca sense aquest submòdul, encara tens el directori del submòdul com un directori no seguit:

[source,console]
----
$ git --version
git version 2.12.2

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)
----

Eliminar el directori no és difícil, però pot ser una mica confús tenir això allà. Si l'eliminar i després tornes a la branca que té aquest submòdul, hauràs d'executar `submodule update --init` per tornar a poblar-lo.

[source,console]
----
$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src
----

Un altre cop, no realment molt difícil, però pot ser una mica confús.

Les versions més noves de Git (Git >= 2.13) simplifiquen tot això afegint la bandera `--recurse-submodules` al comandament `git checkout`, que s'encarrega de posar els submòduls en l'estat correcte per a la branca a la qual estem canviant.

[source,console]
----
$ git --version
git version 2.13.3

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout --recurse-submodules master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

nothing to commit, working tree clean
----

Utilitzar la bandera `--recurse-submodules` de `git checkout` també pot ser útil quan treballes en diverses branques al superprojecte, cadascuna amb el teu submòdul apuntant a diferents commits. De fet, si canvies entre branques que registren el submòdul en diferents commits, en executar `git status` el submòdul apareixerà com a "`modificat`", i indicarà "`nous commits`". Això és perquè l'estat del submòdul per defecte no es porta quan canvies de branques.

Això pot ser realment confús, així que és una bona idea sempre utilitzar `git checkout --recurse-submodules` quan el teu projecte té submòduls. Per a versions més antigues de Git que no tenen la bandera `--recurse-submodules`, després del checkout pots utilitzar `git submodule update --init --recursive` per posar els submòduls en l'estat correcte.

Afortunadament, pots dir a Git (>=2.14) que sempre utilitzi la bandera `--recurse-submodules` establint l'opció de configuració `submodule.recurse`: `git config submodule.recurse true`. Com s'ha esmentat anteriorment, això també farà que Git es recursi en submòduls per a cada comandament que té una opció `--recurse-submodules` (excepte `git clone`).

===== Canviant de Subdirectoris a Submòduls

L'altra advertència principal que moltes persones troben implica canviar de subdirectoris a submòduls. Si has estat seguint fitxers al teu projecte i vols moure'ls a un submòdul, has de ser cuidadosa o Git s'enfadarà amb tu. Suposa que tens fitxers en un subdirectori del teu projecte, i vols canviar-lo a un submòdul. Si elimines el subdirectori i després executes `submodule add`, Git et crida:

[source,console]
----
$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index
----

Has de desfer el `CryptoLibrary` primer. Després pots afegir el submòdul:

[source,console]
----
$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

Ara suposem que ho vas fer en una branca. Si intentes tornar a una branca on aquests fitxers encara estan a l'arbre real en lloc d'un submòdul, obtindràs aquest error:

[source,console]
----
$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting
----

Pots forçar que canviï amb `checkout -f`, però tingues cura que no tens canvis no desats allà ja que podrien ser sobreescrits amb aquest comandament.

[source,console]
----
$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
----

Llavors, quan tornis, obtindràs un directori `CryptoLibrary` buit per alguna raó i `git submodule update` potser no ho arregli tampoc. Potser hauràs d'anar al teu directori de submòduls i executar un `git checkout .` per recuperar tots els teus fitxers. Podries executar això en un script `submodule foreach` per executar-lo per a múltiples submòduls.

És important tenir en compte que els submòduls avui en dia mantenen totes les seves dades Git al directori `.git` del projecte principal, així que a diferència de versions molt més antigues de Git, destruir un directori de submòduls no farà perdre cap commit o branca que tinguessis.

Amb aquestes eines, els submòduls poden ser un mètode bastant senzill i efectiu per desenvolupar en diversos projectes relacionats però encara separats simultàniament.
